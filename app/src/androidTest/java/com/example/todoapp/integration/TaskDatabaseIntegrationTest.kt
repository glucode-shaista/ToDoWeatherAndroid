package com.example.todoapp.integration

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.SmallTest
import com.example.todoapp.data.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.io.IOException
import java.time.LocalDateTime

/**
 * Integration tests for TaskDatabase using Room's in-memory database
 * Tests CRUD operations, queries, and complex business logic integrations
 */
@RunWith(AndroidJUnit4::class)
@SmallTest
@ExperimentalCoroutinesApi
class TaskDatabaseIntegrationTest {

    private lateinit var taskDao: TaskDao
    private lateinit var weatherDao: WeatherDao
    private lateinit var database: TaskDatabase

    @Before
    fun createDb() {
        val context = ApplicationProvider.getApplicationContext<android.content.Context>()
        database = Room.inMemoryDatabaseBuilder(
            context, TaskDatabase::class.java
        ).build()
        taskDao = database.taskDao()
        weatherDao = database.weatherDao()
    }

    @After
    @Throws(IOException::class)
    fun closeDb() {
        database.close()
    }

    // ============= CRUD Operations Tests =============

    @Test
    fun createTaskInsertsTaskWithAutoGeneratedID() = runTest {
        // Given
        val task = createTestTask(
            title = "Integration Test Task",
            description = "Testing task creation",
            priority = Priority.High,
            category = Category.WORK
        )

        // When
        taskDao.createTask(task)

        // Then
        val retrievedTask = taskDao.getAllTasks().first().first { it.title == "Integration Test Task" }
        assertEquals("Integration Test Task", retrievedTask.title)
        assertEquals("Testing task creation", retrievedTask.description)
        assertEquals(Priority.High, retrievedTask.priority)
        assertEquals(Category.WORK, retrievedTask.category)
        assertTrue(retrievedTask.id > 0) // Auto-generated ID
        assertFalse(retrievedTask.isCompleted)
        assertFalse(retrievedTask.favorite)
        assertNotNull(retrievedTask.createdDateTime)
    }

    @Test
    fun updateTaskModifiesExistingTask() = runTest {
        // Given - Insert a task first
        val originalTask = createTestTask(title = "Original Task")
        taskDao.createTask(originalTask)
        
        val taskFromDb = taskDao.getAllTasks().first().first { it.title == "Original Task" }
        val updatedTask = taskFromDb.copy(
            title = "Updated Task",
            description = "Updated description",
            priority = Priority.High,
            isCompleted = true,
            favorite = true
        )

        // When
        taskDao.updateTask(updatedTask)

        // Then
        val retrievedTask = taskDao.getAllTasks().first().first { it.id == taskFromDb.id }
        assertEquals("Updated Task", retrievedTask.title)
        assertEquals("Updated description", retrievedTask.description)
        assertEquals(Priority.High, retrievedTask.priority)
        assertTrue(retrievedTask.isCompleted)
        assertTrue(retrievedTask.favorite)
    }

    @Test
    fun deleteTaskRemovesTaskFromDatabase() = runTest {
        // Given - Insert a task first
        val task = createTestTask(title = "Task to Delete")
        taskDao.createTask(task)
        
        val taskFromDb = taskDao.getAllTasks().first().first { it.title == "Task to Delete" }

        // When
        taskDao.deleteTask(taskFromDb)

        // Then
        val remainingTasks = taskDao.getAllTasks().first()
        assertFalse(remainingTasks.any { it.id == taskFromDb.id })
    }

    // ============= Sorting and Priority Tests =============

    @Test
    fun getAllTasksSortsByCompletionPriorityAndDueDateCorrectly() = runTest {
        // Given - Create tasks with different priorities and completion states
        val highPriorityTask = createTestTask(
            title = "High Priority Task",
            priority = Priority.High,
            isCompleted = false,
            dueDateTime = LocalDateTime.now().plusDays(2)
        )
        val mediumPriorityTask = createTestTask(
            title = "Medium Priority Task", 
            priority = Priority.Medium,
            isCompleted = false,
            dueDateTime = LocalDateTime.now().plusDays(1)
        )
        val lowPriorityTask = createTestTask(
            title = "Low Priority Task",
            priority = Priority.Low,
            isCompleted = false,
            dueDateTime = LocalDateTime.now().plusDays(3)
        )
        val completedTask = createTestTask(
            title = "Completed Task",
            priority = Priority.High,
            isCompleted = true
        )

        taskDao.createTask(highPriorityTask)
        taskDao.createTask(mediumPriorityTask)
        taskDao.createTask(lowPriorityTask)
        taskDao.createTask(completedTask)

        // When
        val allTasks = taskDao.getAllTasks().first()

        // Then - Verify correct sorting order
        assertEquals(4, allTasks.size)
        
        // Incomplete tasks should come first (sorted by priority, then due date)
        assertEquals("High Priority Task", allTasks[0].title)
        assertEquals("Medium Priority Task", allTasks[1].title) 
        assertEquals("Low Priority Task", allTasks[2].title)
        
        // Completed task should come last
        assertEquals("Completed Task", allTasks[3].title)
    }

    // ============= Category Filtering Tests =============

    @Test
    fun getTasksByCategoryFiltersCorrectly() = runTest {
        // Given
        val workTask = createTestTask(title = "Work Task", category = Category.WORK)
        val personalTask = createTestTask(title = "Personal Task", category = Category.PERSONAL)
        val shoppingTask = createTestTask(title = "Shopping Task", category = Category.SHOPPING)

        taskDao.createTask(workTask)
        taskDao.createTask(personalTask)
        taskDao.createTask(shoppingTask)

        // When
        val workTasks = taskDao.getTasksByCategory(Category.WORK).first()
        val personalTasks = taskDao.getTasksByCategory(Category.PERSONAL).first()

        // Then
        assertEquals(1, workTasks.size)
        assertEquals("Work Task", workTasks.first().title)
        
        assertEquals(1, personalTasks.size)
        assertEquals("Personal Task", personalTasks.first().title)
    }

    @Test
    fun getIncompleteTasksByCategoryFiltersCorrectly() = runTest {
        // Given
        val workTaskIncomplete = createTestTask(title = "Work Task Pre", category = Category.WORK, isCompleted = false)
        val workTaskComplete = createTestTask(title = "Work Task Done", category = Category.WORK, isCompleted = true)
        val personalTaskIncomplete = createTestTask(title = "Personal Task Pre", category = Category.PERSONAL, isCompleted = false)

        taskDao.createTask(workTaskIncomplete)
        taskDao.createTask(workTaskComplete)
        taskDao.createTask(personalTaskIncomplete)

        // When
        val incompleteWorkTasks = taskDao.getIncompleteTasksByCategory(Category.WORK).first()
        val incompletePersonalTasks = taskDao.getIncompleteTasksByCategory(Category.PERSONAL).first()

        // Then
        assertEquals(1, incompleteWorkTasks.size)
        assertEquals("Work Task Pre", incompleteWorkTasks.first().title)
        
        assertEquals(1, incompletePersonalTasks.size)
        assertEquals("Personal Task Pre", incompletePersonalTasks.first().title)
    }

    // ============= Priority Filtering Tests =============

    @Test
    fun getTasksByPriorityFiltersCorrectly() = runTest {
        // Given
        val highTask1 = createTestTask(title = "High Task 1", priority = Priority.High)
        val highTask2 = createTestTask(title = "High Task 2", priority = Priority.High, isCompleted = true)
        val mediumTask = createTestTask(title = "Medium Task", priority = Priority.Medium)

        taskDao.createTask(highTask1)
        taskDao.createTask(highTask2)
        taskDao.createTask(mediumTask)

        // When
        val highTasks = taskDao.getTasksByPriority(Priority.High).first()
        val mediumTasks = taskDao.getTasksByPriority(Priority.Medium).first()

        // Then
        assertEquals(2, highTasks.size)
        assertTrue(highTasks.all { it.priority == Priority.High })
        
        assertEquals(1, mediumTasks.size)
        assertEquals("Medium Task", mediumTasks.first().title)
    }

    @Test
    fun getIncompleteTasksByPriorityFiltersCorrectly() = runTest {
        // Given
        val highComplete = createTestTask(title = "High Complete", priority = Priority.High, isCompleted = true)
        val highIncomplete = createTestTask(title = "High Incomplete", priority = Priority.High, isCompleted = false)
        val lowIncomplete = createTestTask(title = "Low Incomplete", priority = Priority.Low, isCompleted = false)

        taskDao.createTask(highComplete)
        taskDao.createTask(highIncomplete)
        taskDao.createTask(lowIncomplete)

        // When
        val incompleteHighTasks = taskDao.getIncompleteTasksByPriority(Priority.High).first()
        val completeHighTasks = taskDao.getTasksByPriority(Priority.High).first()

        // Then
        assertEquals(1, incompleteHighTasks.size)
        assertEquals("High Incomplete", incompleteHighTasks.first().title)
        
        // Verify complete tasks still show in general priority query
        assertEquals(2, completeHighTasks.size)
    }

    // ============= Combined Filtering Tests =============

    @Test
    fun getTasksByCategoryAndPriorityCombinesFiltersCorrectly() = runTest {
        // Given
        val workHighTask = createTestTask(title = "Work High Task", category = Category.WORK, priority = Priority.High)
        val workMediumTask = createTestTask(title = "Work Medium Task", category = Category.WORK, priority = Priority.Medium)
        val personalHighTask = createTestTask(title = "Personal High Task", category = Category.PERSONAL, priority = Priority.High)

        taskDao.createTask(workHighTask)
        taskDao.createTask(workMediumTask)
        taskDao.createTask(personalHighTask)

        // When
        val workHighTasks = taskDao.getTasksByCategoryAndPriority(Category.WORK, Priority.High).first()
        val workMediumTasks = taskDao.getTasksByCategoryAndPriority(Category.WORK, Priority.Medium).first()

        // Then
        assertEquals(1, workHighTasks.size)
        assertEquals("Work High Task", workHighTasks.first().title)
        
        assertEquals(1, workMediumTasks.size)
        assertEquals("Work Medium Task", workMediumTasks.first().title)
    }

    // ============= Search Functionality Tests =============

    @Test
    fun searchTasksFindsTasksByTitle() = runTest {
        // Given
        val meetingTask = createTestTask(title = "Team Meeting", description = "Weekly team sync")
        val standupTask = createTestTask(title = "Daily Standup", description = "Morning team meeting")
        val codingTask = createTestTask(title = "Code Review", description = "Review pull requests")

        taskDao.createTask(meetingTask)
        taskDao.createTask(standupTask)
        taskDao.createTask(codingTask)

        // When
        val meetingResults = taskDao.searchTasks("meeting").first()
        val teamResults = taskDao.searchTasks("team").first()

        // Then
        assertEquals(2, meetingResults.size)
        assertTrue(meetingResults.any { it.title == "Team Meeting" })
        assertTrue(meetingResults.any { it.title == "Daily Standup" })
        
        assertEquals(2, teamResults.size)
        assertTrue(teamResults.any { it.title.contains("team", ignoreCase = true) })
    }

    @Test
    fun searchTasksHandlesPartialMatches() = runTest {
        // Given
        val importantTask = createTestTask(title = "Important Meeting", description = "Project planning")
        val urgentTask = createTestTask(title = "Urgent Review", description = "Code review")

        taskDao.createTask(importantTask)
        taskDao.createTask(urgentTask)

        // When
        val reviewResults = taskDao.searchTasks("review").first()
        val importantResults = taskDao.searchTasks("important").first()

        // Then
        assertEquals(1, reviewResults.size)
        assertEquals("Urgent Review", reviewResults.first().title)
        
        assertEquals(1, importantResults.size)
        assertEquals("Important Meeting", importantResults.first().title)
    }

    // ============= Favorite Tasks Tests =============

    @Test
    fun getFavoriteTasksReturnsOnlyFavoritedTasks() = runTest {
        // Given
        val favoriteTask1 = createTestTask(title = "Favorite Task 1", favorite = true)
        val favoriteTask2 = createTestTask(title = "Favorite Task 2", favorite = true, isCompleted = true)
        val regularTask = createTestTask(title = "Regular Task", favorite = false)

        taskDao.createTask(favoriteTask1)
        taskDao.createTask(favoriteTask2)
        taskDao.createTask(regularTask)

        // When
        val favorites = taskDao.getFavoriteTasks().first()

        // Then
        assertEquals(2, favorites.size)
        assertEquals("Favorite Task 1", favorites[0].title)
        assertEquals("Favorite Task 2", favorites[1].title)
        assertTrue(favorites.all { it.favorite })
    }

    // ============= Date-based Tests =============

    @Test
    fun getTodayTasksReturnsTasksDueToday() = runTest {
        // Given
        val today = LocalDateTime.now()
        val tomorrow = today.plusDays(1)
        val yesterday = today.minusDays(1)
        
        val todayTask = createTestTask(title = "Due Today", dueDateTime = today)
        val tomorrowTask = createTestTask(title = "Due Tomorrow", dueDateTime = tomorrow)
        val yesterdayTask = createTestTask(title = "Due Yesterday", dueDateTime = yesterday)

        taskDao.createTask(todayTask)
        taskDao.createTask(tomorrowTask)
        taskDao.createTask(yesterdayTask)

        // When
        val todayTasks = taskDao.getTodayTasks().first()

        // Then - Room's date function works with 'now' so we expect only today's tasks
        assertEquals("Due Today", todayTasks.first().title)
        assertEquals(1, todayTasks.size)
    }

    @Test
    fun dueDateTimeComparison() = runTest {
        // Given - Create tasks with specific date relationships
        val now = LocalDateTime.now()
        val overdueTask = createTestTask(
            title = "Overdue Task",
            dueDateTime = now.minusDays(1),
            isCompleted = false
        )
        val upcomingTask = createTestTask(
            title = "Upcoming Task", 
            dueDateTime = now.plusDays(1),
            isCompleted = false
        )
        val completedOverdueTask = createTestTask(
            title = "Completed Overdue Task",
            dueDateTime = now.minusDays(1), 
            isCompleted = true
        )

        taskDao.createTask(overdueTask)
        taskDao.createTask(upcomingTask)
        taskDao.createTask(completedOverdueTask)

        // When
        val overdueTasks = taskDao.getOverdueTasks().first()

        // Then - Only incomplete overdue tasks should be returned
        assertEquals(1, overdueTasks.size)
        assertEquals("Overdue Task", overdueTasks.first().title)
        assertFalse(overdueTasks.first().isCompleted)
    }

    // ============= Completion Status Tests =============

    @Test
    fun getCompletedTasksReturnsOnlyCompletedTasks() = runTest {
        // Given
        val completedTask1 = createTestTask(title = "Completed 1", isCompleted = true)
        val completedTask2 = createTestTask(title = "Completed 2", isCompleted = true, priority = Priority.High)
        val incompleteTask = createTestTask(title = "Incomplete", isCompleted = false)

        taskDao.createTask(completedTask1)
        taskDao.createTask(completedTask2)
        taskDao.createTask(incompleteTask)

        // When
        val completedTasks = taskDao.getCompletedTasks().first()
        val incompleteTasks = taskDao.getIncompleteTasks().first()

        // Then
        assertEquals(2, completedTasks.size)
        assertTrue(completedTasks.all { it.isCompleted })
        
        assertEquals(1, incompleteTasks.size)
        assertEquals("Incomplete", incompleteTasks.first().title)
        assertFalse(incompleteTasks.first().isCompleted)
    }

    // ============= Stress Tests =============

    @Test
    fun bulkInsertMultipleTasks() = runTest {
        // Given - Create multiple tasks to test bulk operations
        val tasks = (1..50).map { i ->
            createTestTask(
                title = "Task $i",
                description = "Description for task $i",
                priority = when (i % 3) {
                    0 -> Priority.Low
                    1 -> Priority.Medium  
                    2 -> Priority.High
                    else -> Priority.Medium
                },
                category = when (i % 5) {
                    0 -> Category.WORK
                    1 -> Category.PERSONAL
                    2 -> Category.SHOPPING
                    3 -> Category.HEALTH
                    else -> Category.OTHER
                },
                isCompleted = i % 7 == 0, // 1/7 tasks completed
                favorite = i % 11 == 0    // 1/11 tasks favorited
            )
        }

        // When - Insert all tasks
        tasks.forEach { taskDao.createTask(it) }

        // Then - Verify all tasks were inserted and retrieved correctly
        val allTasks = taskDao.getAllTasks().first()
        assertEquals(50, allTasks.size)
        
        // Verify counts by category
        val workTasks = taskDao.getTasksByCategory(Category.WORK).first()
        assertEquals(10, workTasks.size)
        
        // Verify completed count
        val completedCount = taskDao.getCompletedTasks().first().size
        assertTrue(completedCount > 0) // At least some tasks should be completed
        
        // Verify favorite count
        val favoriteCount = taskDao.getFavoriteTasks().first().size
        assertTrue(favoriteCount > 0) // At least some tasks should be favorited
    }

    @Test
    fun concurrentOperations() = runTest {
        // Given - Simulate concurrent operations
        val tasks = (1..10).map { createTestTask(title = "Concurrent Task $it") }

        // When
        tasks.forEach { taskDao.createTask(it) }
        
        // Update some tasks
        val tasksFromDb = taskDao.getAllTasks().first()
        val firstHalf = tasksFromDb.take(5)
        firstHalf.forEach { task ->
            val updated = task.copy(priority = Priority.High, isCompleted = true)
            taskDao.updateTask(updated)
        }

        // Then - Verify all operations succeeded
        val updatedTasks = taskDao.getAllTasks().first()
        assertEquals(10, updatedTasks.size)
        
        val highPriorityTasks = taskDao.getTasksByPriority(Priority.High).first()
        assertEquals(5, highPriorityTasks.size)
        
        val completedTasks = taskDao.getCompletedTasks().first()
        assertEquals(5, completedTasks.size)
    }

    // ============= Helper Methods =============

    private fun createTestTask(
        title: String = "Test Task",
        description: String = "Test Description",
        priority: Priority = Priority.Medium,
        category: Category = Category.OTHER,
        isCompleted: Boolean = false,
        favorite: Boolean = false,
        dueDateTime: LocalDateTime? = null,
        createdDateTime: LocalDateTime = LocalDateTime.now()
    ) = Task(
        title = title,
        description = description,
        priority = priority,
        category = category,
        isCompleted = isCompleted,
        favorite = favorite,
        dueDateTime = dueDateTime,
        createdDateTime = createdDateTime
    )
}
